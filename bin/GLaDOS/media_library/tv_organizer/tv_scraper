#!/bin/bash
#
###############################
### TMDB movie scraper
### Author: Jeremiah Jackson
##############################

###############################################################
### This section sets the DIR variable to the current path
### allowing the script to run from anywhere on the filesystem
### as long as the directory structure within this app stays
### intact.
###############################################################
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

#############################
### Libraries and Functions
#############################
source $DIR/lib/vars
for f in $DIR/lib/functions/*; do if [ -f $f ]; then source $f; fi;done
for f in $DIR/lib/functions/tv_functions/*; do source $f; done
source $pLIB/colors

dl_flag=0;
trust_flag=0;
kodi_flag=0;
rss_flag=1;
copy_flag=0;
multipart_episode_numbers=1;

inputFile="NO_FILE"
while getopts ":f:htdkrlc" OPTION; do
 case $OPTION in
   h) tv_usage; exit 1;;
   f) inputFile=$OPTARG;;
   d) echo "set download flag";dl_flag=1;;
   t) trust_flag=1;;
   k) kodi_flag=1;;
   r) rss_flag=0;;
   l) kodi_flag=1;dl_flag=1;;
   c) copy_flag=1;;
 esac
done
if [ "$inputFile" == "NO_FILE" ] && [ "$1" != "" ]; then
 inputFile=$1
fi

if [ "$inputFile" == "NO_FILE" ]; then
	echo "No input file specified! Exiting"
	exit 1;
fi

showpath="/shares/video/tv/"
pathlen=${#showpath}
DirArray=($showpath*/)
if [ ! -f "$inputFile" ]; then
#	echo "Didn't find $inputFile!"
	inputFile=`find . -iname "$inputFile"*`
	if [ "$inputFile" == "" ]; then
		exit 1
	else
		if [ "${inputFile:0:2}" == "./" ]; then
			inputFile=${inputFile:2}
		fi
#	        echo "now $inputFile"
	fi
fi

originalFile=$inputFile

if [ -n "$3" ] && [ "$2" != "-f" ]; then
 FoundShowName=$3
else
 FoundShowName=
fi

if [ -n $4 ]; then
 Season=$4
else
 Season=
fi

EN=
Title=
FILESIZE=`du -h "$inputFile" | awk '{print $1;}'`"B"
quality=$(get_media_quality "$inputFile")
duration=$(get_media_length "$inputFile")
mType=$(get_media_type "$inputFile")


## RSS Path and Variables
RSS_Path="/shares/filesystem/apache/rss/tv/tv.rss"

## Remove leading path from Direcotry path
counter=0
while [ $counter -lt ${#DirArray[@]} ]; do
	word=${DirArray[$counter]}
	len=${#word}
	let len=$len-$pathlen
	let len=$len-1
	word=${word:$pathlen:$len}
#	echo "inserting $word at $counter"
	DirArray[$counter]=$word
	let counter=$counter+1
done


#This should take the input file and rename for appropriate use
inputFile=$(formatFileName "$inputFile")

echo -e "${black}---------------------------------------------------------${NC}"
echo "Parsing $originalFile..."
 extension="${inputFile##*.}"


IFS='.' read -a ShowNameArray <<< "$inputFile"
#checkShowName finds the name of the show from the filename
if [ "$FoundShowName" = "" ]; then
	checkShowName "$inputFile"
fi

IFS=' ' read -a DirName <<< $FoundShowName
nextword=${#DirName[@]}
EP=${ShowNameArray[$nextword]}
if [ -n $EP ]; then
while [ "${EP:0:1}" != "S" ] && [ "${EP:0:1}" != "s" ]; do
#echo "$EP"
	if [[ $EP =~ $numbers ]]; then
		if [ ${#EP} = 3 ]; then
			EP="S0${EP:0:1}E${EP:1}"
		elif [ ${#EP} = 4 ]; then
		     if [ "${EP:0:2}" != "19" ] && [ "${EP:0:2}" != "20" ]; then
			EP="S${EP:0:2}E${EP:2}"
		     else
			nextword=$((nextword+1))
			EP=${ShowNameArray[$nextword]}
		     fi
		else
			PromptForEpInfo
			EP="S$Season"
                        EP=$EP"E$EN"
		fi
	else
	if [ $nextword -lt ${#ShowNameArray[@]} ]; then
		let nextword=$nextword+1
		EP=${ShowNameArray[$nextword]}
#		echo "Moved EP to $EP"
		if [ "$EP" = "" ]; then
			PromptForEpInfo
			EP="S$Season"
			EP=$EP"E$EN"
		fi
	else
		PromptForEpInfo
		break
	fi
	fi
done
	if [ "$EP" != "" ]; then
		Season=${EP:1:2}
		EN=${EP:4:2}
                if [ "${EP:6:1}" == "E" ]; then
                  multipart_episode_numbers=2  
                fi
          if [ $multipart_episode_numbers != 1 ]; then
           echo -e "found ${white}$multipart_episode_numbers${NC} episodes: ${white}${EP:4:2}${NC} ,${white}${EP:7:2}${NC}"
	  fi
	fi
#echo "Season $Season, Episode $EN"
else
	PromptForEpInfo
fi


### At this point, we should have a show name, a season, and an episode number
echo -en "${gray}--Checking ${yellow}$FoundShowName ${NC} Season ${blue}$Season${NC} ... "
sizeDisplay "$FILESIZE"
#create the new season if it doesn't exist
checkSeasonFolder "$FoundShowName" "$Season" "$showpath"



## Build the path
NewPath="$showpath"
for word in ${DirName[@]}; do
	NewPath="$NewPath$word\ "
done
len=${#NewPath}
let len=$len-2
NewPath=${NewPath:0:$len}
NewPath="$NewPath/Season\ $Season/"

## Now check for existing show in that path
NewPath=`echo ${NewPath//[\\\]/}`
EP="S$Season"
EP=$EP"E$EN"

found=`find "$NewPath" -iname "*$EP*" |grep -v srt`
if [ -z "$found" ]; then
	promptForTitle "$FoundShowName" "$Season" "$EN" "$multipart_episode_numbers"
	MyNewFileName=`echo $FoundShowName |tr ' ' '.'`
	case "$MyNewFileName" in
		"CSI.-.Crime.Scene.Investigation")
			MyNewFileName="CSI"
			;;
	esac
        if [ $multipart_episode_numbers -gt 1 ]; then
         cntr=1
         e2=$EN
         while [ $cntr -lt $multipart_episode_numbers ]; do
          e2=$((e2+1))
          cntr=$((cntr+1))
           if [ $e2 -lt 10 ] && [ ${#e2} -lt 2 ]; then
             e2="0$e2"
           fi
          EP=$EP"E"$e2
         done
        fi
	MyNewFileName=$MyNewFileName"."$EP"."$Title"."$extension
	NewPath=$NewPath$MyNewFileName
#echo "moving to $NewPath"
	CreateRSS "$FoundShowName" "$Season" "$Title" "$EN" "$NewPath"
	UpdateTVFeedDB "$FoundShowName" "$Season" "$EN" "$Title" "$FILESIZE" "$quality" "$duration" "$mType" "$multipart_episode_numbers"
	MoveFile "$NewPath"
else
	echo "$FoundShowName Season $Season Episode $EN already exists!"
        #get original file name
	OrFN=$(ls "$showpath$FoundShowName/Season $Season" |grep "E$EN")
	if [ $trust_flag == 1 ]; then
  	 yesNo="y"
        else
         yesNo=
        fi
	while [ "${yesNo,,}" != "y" ] && [ "${yesNo,,}" != "n" ]; do
		echo "Would you like to replace"
		echo -e "   -    ${Cyan}$OrFN${NC} (${red}`du -h \"$found\" | awk '{print $1;}'`${NC})"
		echo " with"
		echo -e "   -    ${ICyan}$1${NC} (${IRed}`du -h \"$1\" |awk '{print $1}'`${NC})"
		read -p "([Y]es/[n]o/[v]iew Directory): " yesNo
			if [ -z $yesNo ]; then
                        yesNo='y'
                fi
	        if [ "${yesNo,,}" == "v" ]; then
        	        echo " Here is a listing of episodes:"
                	echo `ls "$NewPath"`
	                echo ""
        	fi
                if [ "${yesNo,,}" != "y" ] && [ "${yesNo,,}" != "n" ]; then
                        yesNo=
                fi
	done

        if [ "${yesNo,,}" == "n" ]; then
                echo "Exiting..."
                exit 0
        else
#		TitleYN=
#		while [ "${TitleYN,,}" != "y" ] && [ "${TitleYN,,}" != "n" ]; do
Title=`echo "$found" |awk -F"$EN" '{print $NF}'`
Title=${Title:1:${#Title}}
let len=${#Title}-4
Title=${Title:0:$len}
Title=`echo $Title |tr '.' ' '`

#		promptForTitle "$FoundShowName" "$Season" "$EN" "$multipart_episode_numbers" "$Title"
		promptForTitle "$FoundShowName" "$Season" "$EN" "$multipart_episode_numbers"
#		fi
	       	MyNewFileName=`echo $FoundShowName |tr ' ' '.'`
	       	MyNewFileName=$MyNewFileName"."$EP"."$Title"."$extension
	        MyNewFileName=`echo $MyNewFileName |tr ' ' '.'`
	       	NewPath=$NewPath$MyNewFileName
		
		CreateRSS "$FoundShowName" "$Season" "$Title" "$EN" "$NewPath"
		UpdateTVFeedDB "$FoundShowName" "$Season" "$EN" "$Title" "$FILESIZE" "$quality" "$duration" "$mType" "$multipart_episode_numbers"
	        MoveFile "$NewPath"
                if [ "$found" != "$NewPath" ]; then
	          if [ "$copy_flag" == "0" ]; then
                   echo -e "${red}Deleting $found${NC}"
                   rm "$found"
		  fi
                  #echo "$found"
                  #echo "$NewPath"
                else
                  echo -e "${yellow}Overwriting $found${NC}"
                fi
        fi #if yesNo

fi

if [ "$dl_flag" == "1" ]; then
 $DIR/epguides/next_episode
fi

if [ "$kodi_flag" == "1" ]; then
 /root/.bin/local/update_kodi_library
fi

clean_thumbs "$originalFile" "$FILESIZE" "$quality" "$duration" "$mType"
echo -e "${black}---------------------------------------------------------${NC}"

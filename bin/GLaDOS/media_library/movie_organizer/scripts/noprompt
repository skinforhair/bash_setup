#!/bin/bash
##############################
### TMDB movie scraper
### Author: Jeremiah Jackson
##############################

###############################################################
### This section sets the DIR variable to the current path
### allowing the script to run from anywhere on the filesystem
### as long as the directory structure within this app stays
### intact.
###############################################################
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

#############################
### Libraries and Functions
#############################
source $DIR/lib/vars
for f in $DIR/lib/functions/*; do source $f; done
OIFS=$IFS

searchTerms=
json_array=
db_array=

#######################################################
### Parse the filename and search online for the movie
### Prompt the user for verification
#######################################################
sTerms=$(parseFilename "$1")
rm *.json
#echo -e "${yellow} $sTerms ${NC}"
IFS='|' read -a searchTerms <<< "$sTerms"
#info "${searchTerms[0]}  -- ${searchTerms[1]}"
#search_tmdb "${searchTerms[0]}" "${searchTerms[1]}" "y"
searchTerms[25]=$(get_tmdb_id "${searchTerms[0]}" "${searchTerms[1]}")


###########################################################
### Now search the local database to see if that movie is 
### already in the library. If so , create an array for 
### the database entry.
###########################################################
dbID=$(get_local_id "${searchTerms[0]}" "${searchTerms[1]}")
 if [ "$dbID" != "" ]; then
  echo -e "I found ${yellow} ${searchTerms[0]} (${searchTerms[1]}) ${NC} in the database..."
  dTerms=$(get_file_info "$dbID")
  IFS='|' read -a dbTerms <<< "$dTerms"
  score=0
  echo -e "${yellow} Database Version: \t ${Cyan} $1: ${NC}"
  for i in 2 3 4; do
	compare_files "$i" "${dbTerms[$i]}" "${searchTerms[$i]}"
  done
  if [ $score -gt 0 ]; then
	defaultCont="y"
  elif [ $score -lt 0 ]; then
	defaultCont="n"
  else
	defaultCont=""
  fi
  #YesNo "\nContinue, making ${Cyan} $1 ${NC} the new version?" "$defaultCont"
   echo "Updating..."
 fi

############################################################
### Next we find the Collection and set this movie belongs to
#############################################################
   prompt_for_sets ${searchTerms[25]} $dbID "y"

 if [ "$dbID" == "" ]; then
	populate_from_json "${searchTerms[0]}" "${searchTerms[1]}"
 else
		populate_from_db "$dbID"
 fi

##########################################
### Now set all the Paths
##########################################
 searchTerms[21]=$(build_paths "${searchTerms[5]}" "${searchTerms[6]}" "${searchTerms[0]}" "${searchTerms[1]}")
 searchTerms[21]="$moviePath${searchTerms[21]}"
 searchTerms[22]=$(build_paths "${searchTerms[5]}" "${searchTerms[6]}" "${searchTerms[0]}" "${searchTerms[1]}" "url")
 searchTerms[22]="$webPath${searchTerms[22]}"


##########################################
### Merge Genres and Keywords from 
### Collection and Set
##########################################
searchTerms[17]=$(merge_terms "genres" "${searchTerms[5]}" "${searchTerms[6]}" "${searchTerms[17]}")
#echo -e "${yellow}-------------${NC}"
searchTerms[18]=$(merge_terms "keywords" "${searchTerms[5]}" "${searchTerms[6]}" "${searchTerms[18]}")

searchTerms[23]=$(my_filename "${searchTerms[0]}" "${searchTerms[1]}" "${searchTerms[4]}")


#########################################
### Move files to the temp directory
#########################################
if [ "$dbID" != "" ]; then
  if [ "${searchTerms[21]}" != "${dbTerms[7]}" ] && [ "${searchTerms[21]}/" != "${dbTerms[7]}" ]; then
	#echo -e "${red} moving to a new location!${NC}"
	reuse_files "${dbTerms[7]}" "${searchTerms[21]}" "${searchTerms[23]}"
  else
	reuse_files "${searchTerms[21]}" "${searchTerms[21]}" "${searchTerms[23]}"
  fi
else
  reuse_files "${searchTerms[21]}" "${searchTerms[21]}" "${searchTerms[23]}"
fi

	if [ ! -d "${searchTerms[21]}" ]; then
		echo -e "Creating path ${yellow}${searchTerms[21]}${NC}"
		mkdir -p "${searchTerms[21]}"
	fi 
	mv "$1" "${searchTerms[23]}.${searchTerms[2]}"
	mv "${searchTerms[23]}.${searchTerms[2]}" "${searchTerms[21]}"
	mv $tempPath/* "${searchTerms[21]}"

       #delete the old path
        if [ "${searchTerms[21]}" != "${dbTerms[7]}" ] && [ "${searchTerms[21]}/" != "${dbTerms[7]}" ]; then
	  localDir=`pwd`
	  if [ "$localDir" != "$moviePath/${dbTerms[7]}" ] && [ "$localDir/" != "$moviePath/${dbTerms[7]}" ]; then
	   echo -e "${yellow}${searchTerms[21]}${NC} != ${yellow}${dbTerms[7]}${NC}"
	   YesNo "Delete ${dbTerms[7]}? " "y"
	     if [ "$?" == "1" ]; then
                rm "${dbTerms[7]}" -rf
	     fi
	  fi
        fi
update_database "$dbID"

#######################
### Display the array
#######################

#display_array

#display_original

  #     - update/insert database for known fields
  #  If file already was in DB, but was updated

IFS=$OIFS

#!/bin/bash
##############################
### TMDB movie scraper MK III
### April 2017
### Author: Jeremiah Jackson
##############################

#########################
### TEST MODE
#########################

#This variable sets whether we actually make changes, or just do a dry run
TESTMODE=0

#This variable is for when adding new movies with a rifftrax added
RIFFTAG=0

###############################################################
### This section sets the DIR variable to the current path
### allowing the script to run from anywhere on the filesystem
### as long as the directory structure within this app stays
### intact.
###############################################################
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

#############################
### Libraries and Functions
#############################
source $DIR/lib/vars

for f in $DIR/lib/functions/*; do source $f; done
OIFS=$IFS

#Initialize Arrays
nameArray=
build_array_reference
searchTerms=
[ "$(ls -A $tempPath)" ] && rm $tempPath/*

jsonFile=$tempPath/current.json
if [ -a $jsonFile ]; then rm $jsonFile; fi

#######################################################
### Parse the filename and search online for the movie
### Prompt the user for verification
#######################################################


#Because Files are often near files with the same name, sometimes
#tab completion leaves off the file extension. Check for that.
if ! [ -a "$1" ]; then
  if [ -a "$1mp4" ]; then
	checkName="$1mp4"
  elif [ -a "$1m4v" ]; then
	checkName="$1m4v"
  elif [ -a "$1avi" ]; then
	checkName="$1avi"
  elif [ -a "$1mkv" ]; then
	checkName="$1mkv"
  else
	checkName="$1"
  fi
else
  checkName="$1"
fi

#The second file passed should be an srt file
#after we populate the array, we'll come back and grab it
case "$2" in
  [rR][iI][fF][fF] | [rR][iI][fF][fF][tT][rR][aA][xX] ) RIFFTAG=1;srtInput=;;
  * )  srtInput="$2";;
esac


#echo "riff is $RIFFTAG , srtinput is $srtInput"
#Parse the remaining filename. Return an array with [title][year][filetype][size][quality]
echo -e "Parsing ${red}$checkName${NC}..."
sTerms=$(parseFilename "$checkName")
IFS='|' read -a searchTerms <<< "$sTerms"

#if a movie was found in the db, but name doesn't quite match, verify it:
if [ "${searchTerms[0]}" != "" ]; then
 checkTitle=$(echo "select title from $movieTable where id='${searchTerms[0]}'"|mysql $dbOptions)
 if [ "$checkTitle" != "${searchTerms[1]}" ]; then
  YesNo "Verify: I found ${yellow}$checkTitle${NC} in the DB. Is this correct?" "y"
  if [ "$?" == "0" ]; then
    searchTerms[0]=
  fi
 fi
fi


#We'll use this variable going forward to indicate if the movie is already in the local db
dbID="${searchTerms[0]}"

##############################
### if movie is in db, verify
### that it is correct and 
### populate the array
##############################
if [ "$dbID" != "" ]; then
   foundyear=
   foundID=

   #if title was found under a different year, this catches it
   checkpoint=${dbID:$((${#dbID}-5)):1}
    if [ "$checkpoint" == "_" ]; then
     foundyear=${dbID:$((${#dbID}-4)):4}
     foundID=${dbID:0:$((${#dbID}-5))}
     dbID=$foundID
    fi #found checkpoint
   populate_dbTerms "$dbID"

   echo -e "I found : ${yellow} ${dbTerms[1]} ${NC}(${yellow}${dbTerms[2]}${NC}) ${yellow}${dbTerms[6]} minutes${NC} in the database..."
   #verify if it is a different movie with the same title
   #This happens when a new movie comes out with the same name as an old one
    if [ "$foundyear" != "" ]; then
     YesNo "The year ($foundyear) is different than the DB version (${dbTerms[2]}). Is this a new movie?" "n"
     if [ "$?" = "1" ]; then
 	 dbID=
	 searchTerms[0]=""
     else
	dbID=$foundID
 	searchTerms[0]="$dbID"
	searchTerms[2]=$foundyear
     fi #YesNo
    fi #if foundyear != ""

 #NOW, if we still have a dbID, compare the new movie with the DB version
   if [ "$dbID" != "" ]; then
    populate_dbTerms "$dbID"
    #Skip detailed comparison if it is the same movie file being modified
    isSameFile=$(check_same_file)
    if [ "$isSameFile" == "false" ]; then
     score=0
     echo -e "${yellow} Database Version: \t ${Cyan} New File: ${NC}"
     for i in 3 4 5; do
#	echo "compare_files $i ${dbTerms[$i]} ${searchTerms[$i]} $RIFFTAG"
	compare_files "$i" "${dbTerms[$i]}" "${searchTerms[$i]}" "$RIFFTAG"
     done #3 4 5
     echo -en "\nThe score is ["
     if [ $score -gt 29 ]; then
	defaultCont="y"
        echo -en "${green}"
     elif [ $score -lt 19 ]; then
	defaultCont="n"
        echo -en "${red}"
     else
	defaultCont=""
	echo -en "${yellow}"
     fi #score
     echo -e " $score ${NC}]"
     newFileFull=`readlink -f "$checkName"`
     newFilePath=`dirname "$newFileFull"`
    if [ $score == 0 ]; then
      defaultCont="y"
    fi #if score==0
    YesNo "\nContinue, making ${red}$newFilePath/${Cyan}$checkName ${NC} the new version?" "$defaultCont"
     if [ "$?" = "0" ]; then
      YesNo "Would you like to delete ${red}$newFilePath/${Cyan}$checkName${NC}?" "n"
	if [ "$?" = "1" ]; then
		echo "Deleting $checkName"
		rm -f "$newFileFull"
	fi #delete file
	exit 0;
     else
	#Keep the title the way it is
	searchTerms[1]=${dbTerms[1]}
     fi #if would you like to delete
    fi #if isSameFile

  populate_from_db "${searchTerms[0]}"
  echo -e "Pulling data from ${cyan}Local Database${NC}..."
  existingJSON=$(echo "${searchTerms[28]}" |sed "s;:\ ;-\ ;g")
  existingJSON=$(echo "$existingJSON" |sed "s;\ ;.;g")
  existingJSON=${existingJSON:0:4}
  JSON=$(cat "${searchTerms[21]}/"$existingJSON*.json)
  echo $JSON > $jsonFile

   fi #if dbid != ""
fi #if found in the local db.
#else
#else was failing - trying a seperate statement 6/10/17
if [ "$dbID" == "" ]; then

  ########
  ###If movie wasn't found in the local database, look it up in tmdb
  ########
  echo -e "Searching for ${cyan}${searchTerms[1]} (${searchTerms[2]})${NC} in ${yellow}TMDB${NC}..."
  search_tmdb "${searchTerms[1]}" "${searchTerms[2]}"

 #if TMDB ID is blank, find the TMDB id
 if [ "${searchTerms[27]}" == "" ]; then
  searchTerms[27]=$(get_tmdb_id "${searchTerms[1]}" "${searchTerms[2]}")
 fi

 #Get the JSON for the movie from tmdb and store it in a text file
 JSON=$(get_movie_json "${searchTerms[27]}")
 echo "$JSON" > $jsonFile
 populate_from_json

 #Read the json for existing groupings, and prompt the user for shelf and collection
 prompt_for_sets ${searchTerms[27]} $dbID

fi #if in database


#Title.Year.Quality
searchTerms[28]=$(my_filename "${searchTerms[1]}" "${searchTerms[2]}" "${searchTerms[5]}")

## At this point, the array should be complete. Now we 
##########################################
### Set all the Paths
##########################################
 searchTerms[21]=$(build_paths)
 searchTerms[22]=$(build_paths "url")

##########################################
### Merge Genres, Keywords, and Tags from 
### Collection and Shelf
##########################################
for i in {15..17}; do
 searchTerms[$i]=$(merge_terms "${nameArray[$i]}" "${searchTerms[$i]}" "$RIFFTAG")
done

searchTerms[29]="none"
#grab subtitle file if available
if [ "$srtInput" == "" ]; then
  srtInput=$(subtitle_file "$checkName")
 #If I found an srt on my own, verify that it's ok
 if [ "$srtInput" != "" ]; then
  YesNo "I found ${red}$srtInput${NC}. Use?" "y"
  if [ "$?" == "0" ]; then
   srtInput=
  fi
 fi
fi

#if an SRT file has been verified for use, grab it now
 if [ "$srtInput" != "" ]; then
  searchTerms[29]="srt"
#  if [ "$TESTMODE" == "0" ]; then
#   mv "$srtInput" "$tempPath/${searchTerms[28]}.srt"
#  fi
 fi


##################################
### Check the data before writing
##################################
edit_array
searchTerms[28]=$(my_filename "${searchTerms[1]}" "${searchTerms[2]}" "${searchTerms[5]}")

#don't bother with searching for srt if we are just modifying a movie
if [ "${searchTerms[21]}" != $(dirname "$checkName") ]; then
 if [ "$srtInput" != "" ]; then
  if [ "$TESTMODE" == "0" ]; then
   mv "$srtInput" "$tempPath/${searchTerms[28]}.srt"
  fi   
 fi

# if [ "$srtInput" == "" ]; then
#  srtInput=$(subtitle_file "$checkName")
# fi
 #If I found an srt on my own, verify that it's ok
# if [ "$srtInput" != "" ]; then
#  YesNo "I found ${red}$srtInput${NC}. Use?" "y"
#  if [ "$?" == "0" ]; then
#   srtInput=
#  fi
# fi
 #if an SRT file has been verified for use, grab it now
# if [ "$srtInput" != "" ]; then
#  if [ "$TESTMODE" == "0" ]; then
#   mv "$srtInput" "$tempPath/${searchTerms[28]}.srt"
#  else
#   echo "mv $srtInput $tempPath/${searchTerms[28]}.srt"
#  fi
# fi

 #Rename the json file
 mv "$jsonFile" "$tempPath/${searchTerms[28]}.json"
 jsonFile="$tempPath/${searchTerms[28]}.json"

fi #if working in destination path

#####################################
### If the movie was in the db, see 
### if anything has changed
#####################################
#if Movie is new, build an nfo file
if [ "$dbID" == "" ]; then
 build_nfo "${searchTerms[28]}"
else
#otherwise, only build one if things changed
 buildflag=0
 for i in {7..17} {23..25}; do
  if [ $(did_element_change "$i") -eq 1 ]; then
    buildflag=1
  fi
 done
 if [ $buildflag -eq 1 ]; then
  echo -e "Building ${green}NFO${NC}..."
  build_nfo "${searchTerms[28]}"
 else
  #if not building a new nfo, grab the old one
  echo -e "Reusing ${yellow}NFO${NC}"
  if [ -a "${searchTerms[21]}/${searchTerms[28]}.nfo" ]; then
   cp "${searchTerms[21]}/${searchTerms[28]}.nfo" "$tempPath"
  else
   build_nfo "${searchTerms[28]}"
  fi
 fi
fi

#########################################
### If there is an older version of the 
### movie, remove it.
#########################################
if [ "$dbID" != "" ]; then
 #compare local_path
 F="${searchTerms[21]}"
 D="${dbTerms[21]}"

 if [ "${D:$((${#D}-1))}" == "/" ]; then
   D=${D:0:$((${#D}-1))}
 fi

 if [ "${F:$((${#F}-1))}" == "/" ]; then
   F=${F:0:$((${#F}-1))}
 fi
 #if the paths match, delete the old movie file
 if [ "$F" == "$D" ]; then
  #if the quality has changed, then rename old files
  if [ "${dbTerms[5]}" != "${searchTerms[5]}" ]; then
    removeFile=$(echo "${dbTerms[1]}" |sed "s;\ ;.;g")
    removeFile="$removeFile.${dbTerms[2]}.${dbTerms[5]}"
    if [ -a "$D""/""$removeFile"".${dbTerms[3]}" ]; then
     #TEST MODE: uncomment these lines to make it work
      if [ "$TESTMODE" == "0" ]; then
       echo -e "${red} Removing $D/$removeFile.${dbTerms[3]}${NC}"
       rm -f "$D""/""$removeFile"".${dbTerms[3]}"
      else
       echo -e "${red}rm -f ""$D""/""$removeFile"".${dbTerms[3]}""${NC}"
      fi
     ## TEST Mode
    else
      echo "$D""/""$removeFile"".${dbTerms[3]} NOT FOUND!"
    fi
  
  #this should rename all files from title.year.oldQual to title.year.newQual
  echo -e "Updating Quality from ${red}${dbTerms[5]}${NC} to ${yellow}${searchTerms[5]}${NC}"
   if [ "$TESTMODE" == "0" ]; then
    for fType in json jpg nfo srt; do
     if [ -a "$D/$removeFile.$fType" ]; then
       nf=$(echo "${searchTerms[1]}"|sed "s;\ ;.;g")
       mv "$D/$removeFile.$fType" "$D/$nf.${dbTerms[2]}.${searchTerms[5]}.$fType"
     fi
    done
   fi #END TEST MODE
  fi #if quality changed
 fi #if paths match
fi


#########################################
### Move files to the temp directory
#########################################
if [ "$dbID" == "" ]; then
  reuse_files "${searchTerms[21]}" "${searchTerms[28]}"
else
  reuse_files "${dbTerms[21]}" "${searchTerms[28]}"
fi

if [ "$TESTMODE" == "1" ]; then
 if [ ! -d "${searchTerms[21]}" ]; then
   echo -e "Creating path ${yellow}${searchTerms[21]}${NC}"
 fi
   if [ "$checkName" != "${searchTerms[28]}.${searchTerms[3]}" ]; then
    echo "mv \"$checkName\" \"${searchTerms[28]}.${searchTerms[3]}\""
   fi
   echo "mv \"${searchTerms[28]}.${searchTerms[3]}\" \"${searchTerms[21]}\""
   echo "mv $tempPath/* \"${searchTerms[21]}\""

 #if replacing a movie, delete the old path
 if [ "$dbID" != "" ]; then
  if [ "${searchTerms[21]}" != "${dbTerms[21]}" ] && [ "${searchTerms[21]}/" != "${dbTerms[21]}" ]; then
   echo "rm -rf \"${dbTerms[21]}\""  
  fi #local path doesnt match old path
 fi #if dbID != ""

else #NOT TEST MODE
# echo -e "Moving ${red}$checkName${NC} to ${green}${searchTerms[21]}/${searchTerms[23]}.${searchTerms[2]}${NC}"
 if [ ! -d "${searchTerms[21]}" ]; then
   echo -e "Creating path ${yellow}${searchTerms[21]}${NC}"
   mkdir -p "${searchTerms[21]}"
 fi
  if [ "$checkName" != "${searchTerms[28]}.${searchTerms[3]}" ]; then
   mv "$checkName" "${searchTerms[28]}.${searchTerms[3]}"
  fi
   #if current directory
   if [ "$(pwd)" != "${searchTerms[21]}" ]; then 
      echo -e "${red}---------------${NC}"
     mv "${searchTerms[28]}.${searchTerms[3]}" "${searchTerms[21]}"
      echo -e "${red}---------------${NC}"
   fi
   mv $tempPath/* "${searchTerms[21]}"

 #if replacing a movie, delete the old path
 if [ "$dbID" != "" ]; then
  if [ "${searchTerms[21]}" != "${dbTerms[21]}" ] && [ "${searchTerms[21]}/" != "${dbTerms[21]}" ]; then
   rm -rf "${dbTerms[21]}"  
  fi #local path doesnt match old path
 fi #if dbID != ""
fi #testmode

#move array into db
array_to_db

##$DIR/scripts/update_kodi_library
#/shares/filesystem/backup_scripts/video_db
IFS=$OIFS
